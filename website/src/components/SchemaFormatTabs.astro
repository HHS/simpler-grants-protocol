---
import { Code } from "@astrojs/starlight/components";
import { Tabs, TabItem } from "@astrojs/starlight/components";
import { readFileSync } from "fs";
import { join, dirname } from "path";
import yaml from "js-yaml";
import { createAjvWithSchemas } from "../lib/validation";
import type { JsonSchema } from "../lib/schema/schema-loader";
import { SchemaLoadError } from "../lib/schema/schema-loader";
import { Paths } from "../lib/schema/paths";

/**
 * Configuration for a code block to be displayed in a tab.
 * Either provide a literal code string or a file path with optional line range.
 */
interface CodeBlockConfig {
  /** A literal code block to display. If provided, file properties are ignored. */
  code?: string;
  /** Configuration for reading code from a file */
  file?: {
    /** Path to the file relative to the repository root */
    path: string;
    /** Starting line number (1-based) to extract code from */
    startLine?: number;
    /** Ending line number (1-based) to extract code from */
    endLine?: number;
  };
}

/**
 * AJV validator function interface
 */
interface AjvValidator {
  (data: unknown): boolean;
  errors?: Array<{
    instancePath?: string;
    schemaPath?: string;
    message?: string;
    data?: unknown;
  }>;
}

/**
 * Props for the SchemaFormatTabs component.
 * Each prop represents a different tab that can be displayed.
 */
interface Props {
  /** Example JSON code block to display in the "Example" tab */
  example?: CodeBlockConfig;
  /** JSON Schema code block to display in the "JSON Schema" tab */
  jsonSchema?: CodeBlockConfig;
  /** TypeSpec code block to display in the "TypeSpec" tab */
  typeSpec?: CodeBlockConfig;
  /** Python code block to display in the "Python" tab */
  python?: CodeBlockConfig;
}

const { example, jsonSchema, typeSpec, python } = Astro.props;

// Validate that at least one tab is provided
if (!example && !jsonSchema && !typeSpec && !python) {
  throw new Error("SchemaFormatTabs requires at least one tab to be provided");
}

// Create AJV instance for schema reference resolution
const ajv = createAjvWithSchemas();

// Constants for default values and patterns
const CACHED_DATE = new Date();
const DEFAULT_VALUES = {
  UUID: "00000000-0000-0000-0000-000000000000",
  EMAIL: "example@example.com",
  URI: "https://example.com",
  PHONE: "555-123-4567",
  COUNTRY_CODE: "+1",
  STRING: "Sample string value",
  INTEGER: 10,
  NUMBER: 100.5,
  BOOLEAN: true,
  GENERIC_NUMERIC: "123",
  ISO_DATE: CACHED_DATE.toISOString().split("T")[0],
  ISO_TIME: CACHED_DATE.toISOString().split("T")[1].split(".")[0],
  ISO_DATETIME: CACHED_DATE.toISOString(),
} as const;

const PATTERNS = {
  COUNTRY_CODE: "^\\+[1-9][0-9]{0,3}$",
  PHONE: "^[0-9]{3}-[0-9]{3}-[0-9]{4}$",
  EMAIL: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
} as const;

const exampleCode = example ? generateCodeFromSchema(example) : null;
const jsonSchemaCode = jsonSchema ? extractCode(jsonSchema) : null;
const typeSpecCode = typeSpec ? extractCode(typeSpec) : null;
const pythonCode = python ? extractCode(python) : null;

const jsonSchemaUrl = jsonSchema ? extractSchemaUrl(jsonSchema) : null;
const typeSpecUrl = typeSpec ? extractGithubUrl(typeSpec) : null;
const pythonUrl = python ? extractGithubUrl(python) : null;

/**
 * Constructs a schema URL from file path.
 * @param props - The code block configuration
 * @returns The schema URL for the file, or null if no file is specified
 */
function extractSchemaUrl(props: CodeBlockConfig): string | null {
  if (!props.file) {
    return null;
  }

  const baseUrl = "https://commongrants.org/";
  const pathPrefix = `${Paths.PUBLIC_DIR}/`;
  let filePath = props.file.path;

  // Trim public directory prefix if present
  if (filePath.startsWith(pathPrefix)) {
    filePath = filePath.substring(pathPrefix.length);
  }

  return `${baseUrl}${filePath}`;
}

/**
 * Extracts a GitHub URL from file configuration.
 * @param props - The code block configuration
 * @returns The GitHub URL for the file, or null if no file is specified
 */
function extractGithubUrl(props: CodeBlockConfig): string | null {
  if (!props.file) {
    return null;
  }

  const baseUrl = "https://github.com/HHS/simpler-grants-protocol/tree/main/";
  let url = `${baseUrl}/${props.file.path}`;

  if (props.file.startLine || props.file.endLine) {
    const start = props.file.startLine || 1;
    const end = props.file.endLine || start;
    url += `#L${start}`;
    if (end > start) {
      url += `-L${end}`;
    }
  }

  return url;
}

/**
 * Extracts code from either a literal string or a file.
 * @param props - The code block configuration
 * @returns The extracted code as a string
 * @throws Error if file cannot be read or if neither code nor file is provided
 */
function extractCode(props: CodeBlockConfig): string {
  if (props.code) {
    return props.code;
  }
  if (props.file) {
    try {
      const websiteRoot = process.cwd();
      const repoRoot = dirname(websiteRoot);
      const filePath = join(repoRoot, props.file.path);
      const content = readFileSync(filePath, "utf-8");

      if (props.file.startLine || props.file.endLine) {
        const lines = content.split("\n");
        const start = props.file.startLine ? props.file.startLine - 1 : 0;
        const end = props.file.endLine ? props.file.endLine : lines.length;
        return lines.slice(start, end).join("\n");
      }

      return content;
    } catch (error) {
      throw new SchemaLoadError(
        `Error reading file ${props.file.path}`,
        error instanceof Error ? error : new Error(String(error)),
      );
    }
  }
  throw new SchemaLoadError("Either code or file must be provided");
}

/**
 * Generate JSON from a Schema file.
 * @param props - The code block configuration containing the schema file path
 * @returns A JSON string with example data based on the schema, or null if generation fails
 */
function generateCodeFromSchema(props: CodeBlockConfig): string | null {
  if (props.code) {
    return props.code;
  }

  try {
    // Parse the YAML schema
    const content = extractCode(props);
    const schema = yaml.load(content, {
      schema: yaml.CORE_SCHEMA,
    }) as JsonSchema;

    // Generate and validate code
    const exampleData = generateJsonFromSchemaObject(schema, new Set(), schema);
    validateGeneratedExample(exampleData, schema);

    // Format generated code
    return JSON.stringify(exampleData, null, 2);
  } catch (error) {
    console.warn(
      `Could not generate code from schema ${props.file?.path || "unknown"}:`,
      error,
    );
    return null;
  }
}

/**
 * Recursively generate JSON from a JSON Schema object.
 * @param schema - The JSON Schema object
 * @param visitedRefs - Set of visited $ref paths to prevent infinite recursion
 * @param rootSchema - The root schema object for resolving internal $defs
 * @returns Example data matching the schema structure
 */
function generateJsonFromSchemaObject(
  schema: JsonSchema,
  visitedRefs: Set<string>,
  rootSchema?: JsonSchema,
): unknown {
  if (!schema || typeof schema !== "object") {
    return null;
  }

  // Handle $ref references - resolve them by loading the referenced schema file
  if (schema.$ref) {
    // Prevent infinite recursion
    if (visitedRefs.has(schema.$ref)) {
      return null; // Prevent infinite recursion
    }
    visitedRefs.add(schema.$ref);

    // Resolve the reference by loading the referenced schema file
    const referencedSchema = resolveSchemaReference(schema.$ref, rootSchema);
    if (referencedSchema) {
      const result = generateJsonFromSchemaObject(
        referencedSchema,
        visitedRefs,
        rootSchema,
      );
      visitedRefs.delete(schema.$ref); // Remove from visited set after processing
      return result;
    }

    // Generate default value for unresolved refs based on type name
    const defaultValue = generateDefaultValueFromRef(schema.$ref);
    if (defaultValue !== null) {
      visitedRefs.delete(schema.$ref);
      return defaultValue;
    }

    // Return null for refs that cannot be resolved
    visitedRefs.delete(schema.$ref); // Remove from visited set
    return null;
  }

  // Handle anyOf
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const optionToUse = selectOptionWithExamples(schema.anyOf);
    return generateJsonFromSchemaObject(optionToUse, visitedRefs, rootSchema);
  }

  // Handle oneOf
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const optionToUse = selectOptionWithExamples(schema.oneOf);
    return generateJsonFromSchemaObject(optionToUse, visitedRefs, rootSchema);
  }

  // Handle allOf
  if (schema.allOf && Array.isArray(schema.allOf)) {
    const mergedSchema = mergeAllOfSchemas(schema.allOf, rootSchema);

    // Also include properties from the current schema
    if (schema.properties) {
      Object.assign(mergedSchema.properties!, schema.properties);
    }
    if (schema.required) {
      mergedSchema.required!.push(...schema.required);
      // Remove duplicates
      mergedSchema.required = [...new Set(mergedSchema.required)];
    }

    // Prefer examples from the current schema if no examples found yet
    if (
      schema.examples &&
      schema.examples.length > 0 &&
      !mergedSchema.examples!.length
    ) {
      mergedSchema.examples = schema.examples;
    }

    // Generate code from the merged schema
    return generateJsonFromSchemaObject(mergedSchema, visitedRefs, rootSchema);
  }

  // Handle different schema types
  if (schema.type === "object") {
    return generateObjectFromSchema(schema, visitedRefs, rootSchema);
  }

  return generatePrimitiveValue(schema, visitedRefs, rootSchema);
}

/**
 * Resolves a schema reference using AJV's built-in reference resolution.
 * @param ref - The reference string (e.g., "OppStatus.yaml", "#/$defs/RecordEvent")
 * @param rootSchema - The root schema object for resolving internal $defs
 * @returns The parsed schema object, or null if the reference cannot be resolved
 */
function resolveSchemaReference(
  ref: string,
  rootSchema?: JsonSchema,
): JsonSchema | null {
  // Handle internal $defs references (e.g., "#/$defs/RecordEvent")
  const defsSchema = resolveDefsReference(ref, rootSchema);
  if (defsSchema) {
    return defsSchema;
  }

  // Use AJV to resolve external references
  try {
    const resolvedSchema = ajv.getSchema(ref);
    if (resolvedSchema?.schema) {
      const schema = resolvedSchema.schema as JsonSchema;
      // If the resolved schema has $defs, merge them into the rootSchema
      if (schema.$defs && rootSchema) {
        if (!rootSchema.$defs) {
          rootSchema.$defs = {};
        }
        // Merge the $defs from the resolved schema
        Object.assign(rootSchema.$defs, schema.$defs);
      }
      return schema;
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Validates generated example data against a JSON schema using AJV and logs results.
 * @param data - The generated example data to validate
 * @param schema - The JSON schema to validate against
 */
function validateGeneratedExample(data: unknown, schema: JsonSchema): void {
  const schemaId = schema.$id as string | undefined;
  let validate: AjvValidator | undefined;

  if (schemaId && ajv.getSchema(schemaId)) {
    // Schema is already registered, get the existing compiled validator
    validate = ajv.getSchema(schemaId) as AjvValidator;
  } else {
    // Schema is not registered, compile it directly
    validate = ajv.compile(schema) as AjvValidator;
  }

  if (validate && !validate(data)) {
    // Convert AJV errors to a readable format
    const errors = (validate.errors || []).map(
      (error: {
        instancePath?: string;
        schemaPath?: string;
        message?: string;
        data?: unknown;
      }) => ({
        path: error.instancePath || error.schemaPath || "",
        message: error.message || "Validation failed",
        value: error.data,
      }),
    );

    // Log warning with error count
    console.warn(
      `Warning: Generated example for schema ${schemaId || "unknown"} failed validation (${errors.length} errors)`,
    );

    // Log first 3 errors for debugging
    if (errors.length > 0) {
      console.log("Validation errors:", errors);
    }
  }
}

/**
 * Helper function to resolve $defs references
 * @param ref - The reference string
 * @param rootSchema - The root schema object
 * @returns The resolved schema or null
 */
function resolveDefsReference(
  ref: string,
  rootSchema?: JsonSchema,
): JsonSchema | null {
  if (!ref.startsWith("#/$defs/") || !rootSchema?.$defs) {
    return null;
  }

  const defName = ref.replace("#/$defs/", "");
  return rootSchema.$defs[defName] || null;
}

/**
 * Helper function to select an option with examples from anyOf/oneOf arrays
 * @param options - Array of schema options
 * @returns The selected option
 */
function selectOptionWithExamples(options: JsonSchema[]): JsonSchema {
  const optionWithExamples = options.find(
    (option) => option.examples && option.examples.length > 0,
  );
  return optionWithExamples || options[0];
}

/**
 * Helper function to get example value from schema
 * @param schema - The schema object
 * @returns The example value or null
 */
function getExampleValue(schema: JsonSchema): unknown {
  return schema.examples && schema.examples.length > 0
    ? schema.examples[0]
    : null;
}

/**
 * Helper function to generate default value based on reference type
 * @param ref - The reference string
 * @returns Default value based on reference type
 */
function generateDefaultValueFromRef(ref: string): unknown {
  if (ref.includes("uuid")) {
    return DEFAULT_VALUES.UUID;
  }
  if (ref.includes("isoDate")) {
    return DEFAULT_VALUES.ISO_DATE;
  }
  if (ref.includes("isoTime")) {
    return DEFAULT_VALUES.ISO_TIME;
  }
  return null;
}

/**
 * Helper function to generate value from string pattern
 * @param pattern - The regex pattern
 * @returns Generated value based on pattern
 */
function generateValueFromPattern(pattern: string): string {
  if (pattern === PATTERNS.COUNTRY_CODE) {
    return DEFAULT_VALUES.COUNTRY_CODE;
  }
  if (pattern === PATTERNS.PHONE) {
    return DEFAULT_VALUES.PHONE;
  }
  if (pattern === PATTERNS.EMAIL) {
    return DEFAULT_VALUES.EMAIL;
  }

  // Generic pattern matching
  if (pattern.includes("^\\+")) {
    return DEFAULT_VALUES.COUNTRY_CODE;
  }
  if (pattern.includes("@")) {
    return DEFAULT_VALUES.EMAIL;
  }
  if (pattern.includes("[0-9]")) {
    return DEFAULT_VALUES.GENERIC_NUMERIC;
  }

  return DEFAULT_VALUES.STRING;
}

/**
 * Helper function to check if a value is valid (not null or undefined)
 * @param value - The value to check
 * @returns True if value is valid
 */
function isValidValue(value: unknown): boolean {
  return value !== null && value !== undefined;
}

/**
 * Helper function to merge allOf schemas efficiently
 * @param allOfSchemas - Array of schemas to merge
 * @param rootSchema - The root schema for reference resolution
 * @returns Merged schema object
 */
function mergeAllOfSchemas(
  allOfSchemas: JsonSchema[],
  rootSchema?: JsonSchema,
): JsonSchema {
  const mergedSchema: JsonSchema = {
    type: "object",
    properties: {},
    required: [],
    examples: [],
  };

  // Process each allOf item
  for (const item of allOfSchemas) {
    let itemSchema: JsonSchema;

    if (item.$ref) {
      // Resolve the reference
      const resolvedSchema = resolveSchemaReference(item.$ref, rootSchema);
      if (resolvedSchema) {
        itemSchema = resolvedSchema;
      } else {
        continue;
      }
    } else {
      itemSchema = item;
    }

    // Merge properties
    if (itemSchema.properties) {
      Object.assign(mergedSchema.properties!, itemSchema.properties);
    }

    // Merge required fields
    if (itemSchema.required) {
      mergedSchema.required!.push(...itemSchema.required);
    }

    // Prefer examples from the first schema that has them
    if (
      itemSchema.examples &&
      itemSchema.examples.length > 0 &&
      !mergedSchema.examples!.length
    ) {
      mergedSchema.examples = itemSchema.examples;
    }
  }

  // Remove duplicates from required array
  if (mergedSchema.required) {
    mergedSchema.required = [...new Set(mergedSchema.required)];
  }

  return mergedSchema;
}

/**
 * Helper function to generate object properties from schema
 * @param schema - The object schema
 * @param visitedRefs - Set of visited references
 * @param rootSchema - The root schema
 * @returns Generated object
 */
function generateObjectFromSchema(
  schema: JsonSchema,
  visitedRefs: Set<string>,
  rootSchema?: JsonSchema,
): Record<string, unknown> {
  const obj: Record<string, unknown> = {};

  if (schema.properties) {
    // Generate required fields first - ensure ALL required fields are generated
    if (schema.required) {
      for (const requiredKey of schema.required) {
        if (schema.properties[requiredKey]) {
          const propSchema = schema.properties[requiredKey] as JsonSchema;
          let exampleValue = generateJsonFromSchemaObject(
            propSchema,
            visitedRefs,
            rootSchema,
          );

          // If no value was generated and the property has examples, use the first example
          if (
            !isValidValue(exampleValue) &&
            propSchema.examples &&
            propSchema.examples.length > 0
          ) {
            exampleValue = propSchema.examples[0];
          }

          // If still no value, generate a default based on the property name
          if (!isValidValue(exampleValue)) {
            if (requiredKey.includes("sortBy")) {
              exampleValue = "lastModifiedAt";
            } else if (requiredKey === "value") {
              exampleValue = "Sample value";
            } else {
              exampleValue = `Sample ${requiredKey}`;
            }
          }

          obj[requiredKey] = exampleValue;
        }
      }
    }

    // Generate optional fields only if we haven't already generated them
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      const isRequired = schema.required && schema.required.includes(key);
      if (obj[key] !== undefined) {
        continue; // Skip if already generated (required or previously generated)
      }
      if (!isRequired) {
        const exampleValue = generateJsonFromSchemaObject(
          propSchema as JsonSchema,
          visitedRefs,
          rootSchema,
        );
        if (isValidValue(exampleValue)) {
          obj[key] = exampleValue;
        }
      }
    }
  }

  // If the object is empty but has required fields, generate at least one
  if (
    Object.keys(obj).length === 0 &&
    schema.required &&
    schema.required.length > 0
  ) {
    const firstRequired = schema.required[0];
    if (schema.properties && schema.properties[firstRequired]) {
      const exampleValue = generateJsonFromSchemaObject(
        schema.properties[firstRequired] as JsonSchema,
        visitedRefs,
        rootSchema,
      );
      if (isValidValue(exampleValue)) {
        obj[firstRequired] = exampleValue;
      }
    }
  }

  // If the object is empty and has unevaluatedProperties, generate a sample property
  if (Object.keys(obj).length === 0 && schema.unevaluatedProperties) {
    if (
      typeof schema.unevaluatedProperties === "object" &&
      schema.unevaluatedProperties !== null &&
      "$ref" in schema.unevaluatedProperties
    ) {
      const sampleValue = generateJsonFromSchemaObject(
        schema.unevaluatedProperties as JsonSchema,
        visitedRefs,
        rootSchema,
      );
      if (isValidValue(sampleValue)) {
        obj["property"] = sampleValue;
      }
    }
  }

  return obj;
}

/**
 * Helper function to generate value for primitive types
 * @param schema - The schema object
 * @param visitedRefs - Set of visited references
 * @param rootSchema - The root schema
 * @returns Generated value
 */
function generatePrimitiveValue(
  schema: JsonSchema,
  visitedRefs: Set<string>,
  rootSchema?: JsonSchema,
): unknown {
  switch (schema.type) {
    case "array":
      if (schema.items) {
        const itemExample = generateJsonFromSchemaObject(
          schema.items as JsonSchema,
          visitedRefs,
          rootSchema,
        );
        return [itemExample];
      }
      return [];

    case "string": {
      if (schema.enum) {
        return schema.enum[0];
      }
      if (schema.const) {
        return schema.const;
      }
      if (schema.format === "date-time") {
        return DEFAULT_VALUES.ISO_DATETIME;
      }
      if (schema.format === "date") {
        return DEFAULT_VALUES.ISO_DATE;
      }
      if (schema.format === "time") {
        return DEFAULT_VALUES.ISO_TIME;
      }
      if (schema.format === "uri") {
        return DEFAULT_VALUES.URI;
      }
      if (schema.$ref && schema.$ref.includes("uuid")) {
        return DEFAULT_VALUES.UUID;
      }

      const exampleValue = getExampleValue(schema);
      if (exampleValue !== null) {
        return exampleValue;
      }

      if (schema.pattern && typeof schema.pattern === "string") {
        return generateValueFromPattern(schema.pattern);
      }

      return DEFAULT_VALUES.STRING;
    }

    case "integer": {
      const intExample = getExampleValue(schema);
      return intExample !== null ? intExample : DEFAULT_VALUES.INTEGER;
    }

    case "number": {
      const numExample = getExampleValue(schema);
      return numExample !== null ? numExample : DEFAULT_VALUES.NUMBER;
    }

    case "boolean":
      return DEFAULT_VALUES.BOOLEAN;

    default:
      return null;
  }
}
---

<Tabs>
  {
    exampleCode && (
      <TabItem label="Example">
        <p>A JSON example of this model.</p>
        <Code code={exampleCode} lang="json" />
      </TabItem>
    )
  }
  {
    jsonSchemaCode && (
      <TabItem label="JSON Schema">
        <p>
          {"The "}
          <a href={jsonSchemaUrl} target="_blank" rel="noopener noreferrer">
            JSON Schema
          </a>
          {" for this model."}
        </p>
        <Code code={jsonSchemaCode} lang="yaml" />
      </TabItem>
    )
  }
  {
    typeSpecCode && (
      <TabItem label="TypeSpec">
        <p>
          {"The "}
          <a href={typeSpecUrl} target="_blank" rel="noopener noreferrer">
            TypeSpec code
          </a>
          {" for this model."}
        </p>
        <Code code={typeSpecCode} lang="typespec" />
      </TabItem>
    )
  }
  {
    pythonCode && (
      <TabItem label="Python">
        <p>
          {"The "}
          <a href={pythonUrl} target="_blank" rel="noopener noreferrer">
            Python code
          </a>
          {" for this model."}
        </p>
        <Code code={pythonCode} lang="python" />
      </TabItem>
    )
  }
</Tabs>
