---
import { Code } from "@astrojs/starlight/components";
import { Tabs, TabItem } from "@astrojs/starlight/components";
import { readFileSync } from "fs";
import { join, dirname } from "path";
import yaml from "js-yaml";
import { createAjvWithSchemas } from "../lib/validation";

/**
 * Configuration for a code block to be displayed in a tab.
 * Either provide a literal code string or a file path with optional line range.
 */
interface CodeBlockConfig {
  /** A literal code block to display. If provided, file properties are ignored. */
  code?: string;
  /** Configuration for reading code from a file */
  file?: {
    /** Path to the file relative to the repository root */
    path: string;
    /** Starting line number (1-based) to extract code from */
    startLine?: number;
    /** Ending line number (1-based) to extract code from */
    endLine?: number;
  };
}

/**
 * JSON Schema object structure
 */
interface JsonSchema {
  type?: string;
  properties?: Record<string, JsonSchema>;
  required?: string[];
  examples?: unknown[];
  enum?: unknown[];
  items?: JsonSchema;
  $ref?: string;
  anyOf?: JsonSchema[];
  oneOf?: JsonSchema[];
  allOf?: JsonSchema[];
  format?: string;
  $defs?: Record<string, JsonSchema>;
  [key: string]: unknown;
}

/**
 * Props for the SchemaFormatTabs component.
 * Each prop represents a different tab that can be displayed.
 */
interface Props {
  /** Example JSON code block to display in the "Example" tab */
  example?: CodeBlockConfig;
  /** JSON Schema code block to display in the "JSON Schema" tab */
  jsonSchema?: CodeBlockConfig;
  /** TypeSpec code block to display in the "TypeSpec" tab */
  typeSpec?: CodeBlockConfig;
  /** Python code block to display in the "Python" tab */
  python?: CodeBlockConfig;
}

const { example, jsonSchema, typeSpec, python } = Astro.props;

// Validate that at least one tab is provided
if (!example && !jsonSchema && !typeSpec && !python) {
  throw new Error("SchemaFormatTabs requires at least one tab to be provided");
}

// Create AJV instance for schema reference resolution
const ajv = createAjvWithSchemas();

const exampleCode = example ? generateCodeFromSchema(example) : null;
const jsonSchemaCode = jsonSchema ? extractCode(jsonSchema) : null;
const typeSpecCode = typeSpec ? extractCode(typeSpec) : null;
const pythonCode = python ? extractCode(python) : null;

const jsonSchemaUrl = jsonSchema ? extractSchemaUrl(jsonSchema) : null;
const typeSpecUrl = typeSpec ? extractGithubUrl(typeSpec) : null;
const pythonUrl = python ? extractGithubUrl(python) : null;

/**
 * Constructs a schema URL from file path.
 * @param props - The code block configuration
 * @returns The schema URL for the file, or null if no file is specified
 */
function extractSchemaUrl(props: CodeBlockConfig): string | null {
  if (!props.file) {
    return null;
  }

  const baseUrl = "https://commongrants.org/";
  const pathPrefix = "website/public/";
  let filePath = props.file.path;
  
  // Trim public directory prefix if present
  if (filePath.startsWith(pathPrefix)) {
    filePath = filePath.substring(pathPrefix.length);
  }
  
  return `${baseUrl}${filePath}`;
}

/**
 * Extracts a GitHub URL from file configuration.
 * @param props - The code block configuration
 * @returns The GitHub URL for the file, or null if no file is specified
 */
function extractGithubUrl(props: CodeBlockConfig): string | null {
  if (!props.file) {
    return null;
  }

  const baseUrl = "https://github.com/HHS/simpler-grants-protocol/tree/main/";
  let url = `${baseUrl}/${props.file.path}`;
  
  if (props.file.startLine || props.file.endLine) {
    const start = props.file.startLine || 1;
    const end = props.file.endLine || start;
    url += `#L${start}`;
    if (end > start) {
      url += `-L${end}`;
    }
  }
  
  return url;
}

/**
 * Extracts code from either a literal string or a file.
 * @param props - The code block configuration
 * @returns The extracted code as a string
 * @throws Error if file cannot be read or if neither code nor file is provided
 */
function extractCode(props: CodeBlockConfig): string {
  if (props.code) {
    return props.code;
  }
  if (props.file) {
    try {
      const websiteRoot = process.cwd();
      const repoRoot = dirname(websiteRoot);
      const filePath = join(repoRoot, props.file.path);
      const content = readFileSync(filePath, "utf-8");

      if (props.file.startLine || props.file.endLine) {
        const lines = content.split("\n");
        const start = props.file.startLine ? props.file.startLine - 1 : 0;
        const end = props.file.endLine ? props.file.endLine : lines.length;
        return lines.slice(start, end).join("\n");
      }

      return content;
    } catch (error) {
      throw new Error(`Error reading file ${props.file.path}: ${error}`);
    }
  }
  throw new Error("Either code or file must be provided");
}

/**
 * Generate JSON from a Schema file.
 * @param props - The code block configuration containing the schema file path
 * @returns A JSON string with example data based on the schema, or null if generation fails
 */
function generateCodeFromSchema(props: CodeBlockConfig): string | null {
  if (props.code) {
    return props.code;
  }
  try {
    // Parse the YAML schema
    const content = extractCode(props);
    const schema = yaml.load(content, { schema: yaml.CORE_SCHEMA }) as JsonSchema;
    
     // Generate cod3 from the schema
     const exampleData = generateJsonFromSchemaObject(schema, new Set(), schema);
    
    // Format as pretty JSON
    return JSON.stringify(exampleData, null, 2);
  } catch (error) {
    console.warn(`Warning: Could not generate example from schema ${props.file?.path || 'unknown'}: ${error}`);
    return null;
  }
}

/**
 * Recursively generate JSON from a JSON Schema object.
 * @param schema - The JSON Schema object
 * @param visitedRefs - Set of visited $ref paths to prevent infinite recursion
 * @param rootSchema - The root schema object for resolving internal $defs
 * @returns Example data matching the schema structure
 */
function generateJsonFromSchemaObject(schema: JsonSchema, visitedRefs: Set<string>, rootSchema?: JsonSchema): unknown {
  if (!schema || typeof schema !== 'object') {
    return null;
  }

  // Handle $ref references - resolve them by loading the referenced schema file
  if (schema.$ref) {
    // Prevent infinite recursion
    if (visitedRefs.has(schema.$ref)) {
      return null; // Prevent infinite recursion
    }
    visitedRefs.add(schema.$ref);
    
    // Resolve the reference by loading the referenced schema file
    const referencedSchema = resolveSchemaReference(schema.$ref, rootSchema);
    if (referencedSchema) {
      const result = generateJsonFromSchemaObject(referencedSchema, visitedRefs, rootSchema);
      visitedRefs.delete(schema.$ref); // Remove from visited set after processing
      return result;
    }
    
    // If reference can't be resolved, return null
    visitedRefs.delete(schema.$ref); // Remove from visited set
    return null;
  }

  // Handle anyOf/oneOf/allOf unions
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    // Use the first option in anyOf
    return generateJsonFromSchemaObject(schema.anyOf[0], visitedRefs, rootSchema);
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    // Use the first option in oneOf
    return generateJsonFromSchemaObject(schema.oneOf[0], visitedRefs, rootSchema);
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    // For allOf, we need to process each item and merge the results
    // This is different from anyOf/oneOf where we pick one option
    const allOfResults: unknown[] = [];
    
    for (const item of schema.allOf) {
      if (item.$ref) {
        // Resolve the reference and process it
        const resolvedSchema = resolveSchemaReference(item.$ref, rootSchema);
        if (resolvedSchema) {
          const result = generateJsonFromSchemaObject(resolvedSchema, visitedRefs, rootSchema);
          if (result !== null) {
            allOfResults.push(result);
          }
        }
      } else {
        // Process the item directly
        const result = generateJsonFromSchemaObject(item, visitedRefs, rootSchema);
        if (result !== null) {
          allOfResults.push(result);
        }
      }
    }
    
    // Merge all the results into a single object
    if (allOfResults.length > 0) {
      const mergedResult = allOfResults.reduce((acc: Record<string, unknown>, result) => {
        if (typeof result === 'object' && result !== null) {
          return Object.assign(acc, result as Record<string, unknown>);
        }
        return acc;
      }, {});
      
      // Also process the current schema's own properties
      const currentResult = generateJsonFromSchemaObject({ ...schema, allOf: undefined }, visitedRefs, rootSchema);
      if (currentResult && typeof currentResult === 'object') {
        return Object.assign(mergedResult, currentResult as Record<string, unknown>);
      }
      
      return mergedResult;
    }
    
    // Fallback: process current schema without allOf
    return generateJsonFromSchemaObject({ ...schema, allOf: undefined }, visitedRefs, rootSchema);
  }

  // Handle different schema types
  switch (schema.type) {
    case 'object': {
      const obj: Record<string, unknown> = {};
      
      // If this object has examples, try to use them as a template
      if (schema.examples && schema.examples.length > 0) {
        const example = schema.examples[0];
        if (typeof example === 'object' && example !== null) {
          // Use the example as a template, but still generate missing fields
          for (const [key, value] of Object.entries(example)) {
            if (schema.properties && schema.properties[key]) {
              // Use the example value directly - it's already properly formatted
              obj[key] = value;
            }
          }
        }
      }
      
      if (schema.properties) {
        for (const [key, propSchema] of Object.entries(schema.properties)) {
          const isRequired = schema.required && schema.required.includes(key);
          
          // If we already have a value from examples, use it
          if (obj[key] !== undefined) {
            continue;
          }
          
          const exampleValue = generateJsonFromSchemaObject(propSchema as JsonSchema, visitedRefs, rootSchema);
          
          // Include required fields and optional fields that have valid examples
          if (isRequired || (exampleValue !== null && exampleValue !== undefined)) {
            obj[key] = exampleValue;
          }
        }
      }
      return obj;
    }

    case 'array':
      if (schema.items) {
        const itemExample = generateJsonFromSchemaObject(schema.items as JsonSchema, visitedRefs, rootSchema);
        return [itemExample];
      }
      return [];

    case 'string':
      if (schema.enum) {
        return schema.enum[0];
      }
      if (schema.format === 'date-time') {
        return new Date().toISOString().split('T')[0];
      }
      if (schema.format === 'uri') {
        return "https://example.com";
      }
      if (schema.examples && schema.examples.length > 0) {
        return schema.examples[0];
      }
      return "Sample string value";

    case 'integer':
      if (schema.examples && schema.examples.length > 0) {
        return schema.examples[0];
      }
      return 10;

    case 'number':
      if (schema.examples && schema.examples.length > 0) {
        return schema.examples[0];
      }
      return 100.50;

    case 'boolean':
      return true;

    default:
      return null;
  }
}

/**
 * Resolves a schema reference using AJV's built-in reference resolution.
 * @param ref - The reference string (e.g., "OppStatus.yaml", "#/$defs/RecordEvent")
 * @param rootSchema - The root schema object for resolving internal $defs
 * @returns The parsed schema object, or null if the reference cannot be resolved
 */
function resolveSchemaReference(ref: string, rootSchema?: JsonSchema): JsonSchema | null {
  // Handle internal $defs references (e.g., "#/$defs/RecordEvent")
  if (ref.startsWith('#/$defs/')) {
    if (rootSchema && rootSchema.$defs) {
      const defName = ref.replace('#/$defs/', '');
      return rootSchema.$defs[defName] || null;
    }
    return null;
  }
  
  // Use AJV to resolve external references
  try {
    const resolvedSchema = ajv.getSchema(ref);
    return (resolvedSchema?.schema as JsonSchema) || null;
  } catch {
    return null;
  }
}

---

<Tabs>
  {
    exampleCode && (
      <TabItem label="Example">
        <p>A JSON example of this model.</p>
        <Code code={exampleCode} lang="json" />
      </TabItem>
    )
  }
  {
    jsonSchemaCode && (
      <TabItem label="JSON Schema">
        <p>The {jsonSchemaUrl && <a href={jsonSchemaUrl} target="_blank" rel="noopener noreferrer">JSON Schema</a>} for this model.</p>
        <Code code={jsonSchemaCode} lang="yaml" />
      </TabItem>
    )
  }
  {
    typeSpecCode && (
      <TabItem label="TypeSpec">
        <p>The {typeSpecUrl ? <a href={typeSpecUrl} target="_blank" rel="noopener noreferrer">TypeSpec code</a> : "TypeSpec code"} for this model.</p>
        <Code code={typeSpecCode} lang="typespec" />
      </TabItem>
    )
  }
  {
    pythonCode && (
      <TabItem label="Python">
        <p>The {pythonUrl ? <a href={pythonUrl} target="_blank" rel="noopener noreferrer">Python code</a> : "Python code"} for this model.</p>
        <Code code={pythonCode} lang="python" />
      </TabItem>
    )
  }
</Tabs>
