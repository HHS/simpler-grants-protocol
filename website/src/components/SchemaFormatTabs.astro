---
import { Code } from "@astrojs/starlight/components";
import { Tabs, TabItem } from "@astrojs/starlight/components";
import { readFileSync } from "fs";
import { join, dirname } from "path";
import yaml from "js-yaml";
import { createAjvWithSchemas } from "../lib/validation";

/**
 * Configuration for a code block to be displayed in a tab.
 * Either provide a literal code string or a file path with optional line range.
 */
interface CodeBlockConfig {
  /** A literal code block to display. If provided, file properties are ignored. */
  code?: string;
  /** Configuration for reading code from a file */
  file?: {
    /** Path to the file relative to the repository root */
    path: string;
    /** Starting line number (1-based) to extract code from */
    startLine?: number;
    /** Ending line number (1-based) to extract code from */
    endLine?: number;
  };
}

/**
 * JSON Schema object structure
 */
interface JsonSchema {
  type?: string;
  properties?: Record<string, JsonSchema>;
  required?: string[];
  examples?: unknown[];
  enum?: unknown[];
  items?: JsonSchema;
  $ref?: string;
  anyOf?: JsonSchema[];
  oneOf?: JsonSchema[];
  allOf?: JsonSchema[];
  format?: string;
  $defs?: Record<string, JsonSchema>;
  [key: string]: unknown;
}

/**
 * Props for the SchemaFormatTabs component.
 * Each prop represents a different tab that can be displayed.
 */
interface Props {
  /** Example JSON code block to display in the "Example" tab */
  example?: CodeBlockConfig;
  /** JSON Schema code block to display in the "JSON Schema" tab */
  jsonSchema?: CodeBlockConfig;
  /** TypeSpec code block to display in the "TypeSpec" tab */
  typeSpec?: CodeBlockConfig;
  /** Python code block to display in the "Python" tab */
  python?: CodeBlockConfig;
}

const { example, jsonSchema, typeSpec, python } = Astro.props;

// Validate that at least one tab is provided
if (!example && !jsonSchema && !typeSpec && !python) {
  throw new Error("SchemaFormatTabs requires at least one tab to be provided");
}

// Create AJV instance for schema reference resolution
const ajv = createAjvWithSchemas();

const exampleCode = example ? generateCodeFromSchema(example) : null;
const jsonSchemaCode = jsonSchema ? extractCode(jsonSchema) : null;
const typeSpecCode = typeSpec ? extractCode(typeSpec) : null;
const pythonCode = python ? extractCode(python) : null;

const jsonSchemaUrl = jsonSchema ? extractSchemaUrl(jsonSchema) : null;
const typeSpecUrl = typeSpec ? extractGithubUrl(typeSpec) : null;
const pythonUrl = python ? extractGithubUrl(python) : null;

/**
 * Constructs a schema URL from file path.
 * @param props - The code block configuration
 * @returns The schema URL for the file, or null if no file is specified
 */
function extractSchemaUrl(props: CodeBlockConfig): string | null {
  if (!props.file) {
    return null;
  }

  const baseUrl = "https://commongrants.org/";
  const pathPrefix = "website/public/";
  let filePath = props.file.path;

  // Trim public directory prefix if present
  if (filePath.startsWith(pathPrefix)) {
    filePath = filePath.substring(pathPrefix.length);
  }

  return `${baseUrl}${filePath}`;
}

/**
 * Extracts a GitHub URL from file configuration.
 * @param props - The code block configuration
 * @returns The GitHub URL for the file, or null if no file is specified
 */
function extractGithubUrl(props: CodeBlockConfig): string | null {
  if (!props.file) {
    return null;
  }

  const baseUrl = "https://github.com/HHS/simpler-grants-protocol/tree/main/";
  let url = `${baseUrl}/${props.file.path}`;

  if (props.file.startLine || props.file.endLine) {
    const start = props.file.startLine || 1;
    const end = props.file.endLine || start;
    url += `#L${start}`;
    if (end > start) {
      url += `-L${end}`;
    }
  }

  return url;
}

/**
 * Extracts code from either a literal string or a file.
 * @param props - The code block configuration
 * @returns The extracted code as a string
 * @throws Error if file cannot be read or if neither code nor file is provided
 */
function extractCode(props: CodeBlockConfig): string {
  if (props.code) {
    return props.code;
  }
  if (props.file) {
    try {
      const websiteRoot = process.cwd();
      const repoRoot = dirname(websiteRoot);
      const filePath = join(repoRoot, props.file.path);
      const content = readFileSync(filePath, "utf-8");

      if (props.file.startLine || props.file.endLine) {
        const lines = content.split("\n");
        const start = props.file.startLine ? props.file.startLine - 1 : 0;
        const end = props.file.endLine ? props.file.endLine : lines.length;
        return lines.slice(start, end).join("\n");
      }

      return content;
    } catch (error) {
      throw new Error(`Error reading file ${props.file.path}: ${error}`);
    }
  }
  throw new Error("Either code or file must be provided");
}

/**
 * Generate JSON from a Schema file.
 * @param props - The code block configuration containing the schema file path
 * @returns A JSON string with example data based on the schema, or null if generation fails
 */
function generateCodeFromSchema(props: CodeBlockConfig): string | null {
  if (props.code) {
    return props.code;
  }
  try {
    // Parse the YAML schema
    const content = extractCode(props);
    const schema = yaml.load(content, {
      schema: yaml.CORE_SCHEMA,
    }) as JsonSchema;

    // Generate and validate code
    const exampleData = generateJsonFromSchemaObject(schema, new Set(), schema);
    validateGeneratedExample(exampleData, schema);

    // Format generated code
    return JSON.stringify(exampleData, null, 2);
  } catch (error) {
    console.warn(
      `Warning: Could not generate code from schema ${props.file?.path || "unknown"}: ${error}`,
    );
    return null;
  }
}

/**
 * Recursively generate JSON from a JSON Schema object.
 * @param schema - The JSON Schema object
 * @param visitedRefs - Set of visited $ref paths to prevent infinite recursion
 * @param rootSchema - The root schema object for resolving internal $defs
 * @returns Example data matching the schema structure
 */
function generateJsonFromSchemaObject(
  schema: JsonSchema,
  visitedRefs: Set<string>,
  rootSchema?: JsonSchema,
): unknown {
  if (!schema || typeof schema !== "object") {
    return null;
  }

  // Handle $ref references - resolve them by loading the referenced schema file
  if (schema.$ref) {
    // Prevent infinite recursion
    if (visitedRefs.has(schema.$ref)) {
      return null; // Prevent infinite recursion
    }
    visitedRefs.add(schema.$ref);

    // Resolve the reference by loading the referenced schema file
    const referencedSchema = resolveSchemaReference(schema.$ref, rootSchema);
    if (referencedSchema) {
      const result = generateJsonFromSchemaObject(
        referencedSchema,
        visitedRefs,
        rootSchema,
      );
      visitedRefs.delete(schema.$ref); // Remove from visited set after processing
      return result;
    }

    // Resolve the reference from $defs if it's an internal reference
    if (schema.$ref.startsWith("#/$defs/") && rootSchema && rootSchema.$defs) {
      const defName = schema.$ref.replace("#/$defs/", "");
      const defSchema = rootSchema.$defs[defName];
      if (defSchema) {
        const result = generateJsonFromSchemaObject(
          defSchema,
          visitedRefs,
          rootSchema,
        );
        visitedRefs.delete(schema.$ref);
        return result;
      }
    }

    // Generate default value for unresolved refs based on type name
    if (schema.$ref.includes("uuid")) {
      return "00000000-0000-0000-0000-000000000000";
    }
    if (schema.$ref.includes("isoDate")) {
      return new Date().toISOString().split("T")[0];
    }
    if (schema.$ref.includes("isoTime")) {
      return new Date().toISOString().split("T")[1].split(".")[0];
    }

    // Return null for refs that cannot be resolved
    visitedRefs.delete(schema.$ref); // Remove from visited set
    return null;
  }

  // Handle anyOf
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const optionWithExamples = schema.anyOf.find(
      (option) => option.examples && option.examples.length > 0,
    );
    const optionToUse = optionWithExamples || schema.anyOf[0];
    return generateJsonFromSchemaObject(optionToUse, visitedRefs, rootSchema);
  }

  // Handle oneOf
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const optionWithExamples = schema.oneOf.find(
      (option) => option.examples && option.examples.length > 0,
    );
    const optionToUse = optionWithExamples || schema.oneOf[0];
    return generateJsonFromSchemaObject(optionToUse, visitedRefs, rootSchema);
  }

  // Handle allOf
  if (schema.allOf && Array.isArray(schema.allOf)) {
    // Collect all properties, required fields, and examples from all schemas
    const mergedSchema: JsonSchema = {
      type: "object",
      properties: {},
      required: [],
      examples: [],
    };

    // Process each allOf item
    for (const item of schema.allOf) {
      let itemSchema: JsonSchema;

      if (item.$ref) {
        // Resolve the reference
        const resolvedSchema = resolveSchemaReference(item.$ref, rootSchema);
        if (resolvedSchema) {
          itemSchema = resolvedSchema;
        } else {
          continue;
        }
      } else {
        itemSchema = item;
      }

      // Merge properties
      if (itemSchema.properties) {
        mergedSchema.properties = {
          ...mergedSchema.properties,
          ...itemSchema.properties,
        };
      }

      // Merge required fields
      if (itemSchema.required) {
        mergedSchema.required = [
          ...(mergedSchema.required || []),
          ...itemSchema.required,
        ];
      }

      // Prefer examples from the first schema that has them, but don't require them
      if (
        itemSchema.examples &&
        itemSchema.examples.length > 0 &&
        !mergedSchema.examples?.length
      ) {
        mergedSchema.examples = itemSchema.examples;
      }
    }

    // Also include properties from the current schema
    if (schema.properties) {
      mergedSchema.properties = {
        ...mergedSchema.properties,
        ...schema.properties,
      };
    }
    if (schema.required) {
      mergedSchema.required = [
        ...(mergedSchema.required || []),
        ...schema.required,
      ];
    }

    // Prefer examples from the current schema if no examples found yet
    if (
      schema.examples &&
      schema.examples.length > 0 &&
      !mergedSchema.examples?.length
    ) {
      mergedSchema.examples = schema.examples;
    }

    // Remove duplicates from required array
    if (mergedSchema.required) {
      mergedSchema.required = [...new Set(mergedSchema.required)];
    }

    // Generate code from the merged schema
    return generateJsonFromSchemaObject(mergedSchema, visitedRefs, rootSchema);
  }

  // Handle different schema types
  switch (schema.type) {
    case "object": {
      const obj: Record<string, unknown> = {};

      if (schema.properties) {
        if (schema.required) {
          // Generate all required fields
          for (const requiredKey of schema.required) {
            if (
              schema.properties[requiredKey] &&
              obj[requiredKey] === undefined
            ) {
              const exampleValue = generateJsonFromSchemaObject(
                schema.properties[requiredKey] as JsonSchema,
                visitedRefs,
                rootSchema,
              );
              obj[requiredKey] = exampleValue;
            }
          }
        }

        // Generate optional fields
        for (const [key, propSchema] of Object.entries(schema.properties)) {
          const isRequired = schema.required && schema.required.includes(key);
          if (obj[key] !== undefined) {
            continue;
          }
          if (!isRequired) {
            const exampleValue = generateJsonFromSchemaObject(
              propSchema as JsonSchema,
              visitedRefs,
              rootSchema,
            );
            if (exampleValue !== null && exampleValue !== undefined) {
              obj[key] = exampleValue;
            }
          }
        }
      }

      // If the object is empty but has required fields
      if (
        Object.keys(obj).length === 0 &&
        schema.required &&
        schema.required.length > 0
      ) {
        const firstRequired = schema.required[0];
        if (schema.properties && schema.properties[firstRequired]) {
          const exampleValue = generateJsonFromSchemaObject(
            schema.properties[firstRequired] as JsonSchema,
            visitedRefs,
            rootSchema,
          );
          if (exampleValue !== null && exampleValue !== undefined) {
            obj[firstRequired] = exampleValue;
          }
        }
      }

      // If the object is empty and has unevaluatedProperties
      if (Object.keys(obj).length === 0 && schema.unevaluatedProperties) {
        if (
          typeof schema.unevaluatedProperties === "object" &&
          schema.unevaluatedProperties.$ref
        ) {
          // Generate a property using the unevaluatedProperties schema
          const sampleValue = generateJsonFromSchemaObject(
            schema.unevaluatedProperties as JsonSchema,
            visitedRefs,
            rootSchema,
          );
          if (sampleValue !== null && sampleValue !== undefined) {
            obj["property"] = sampleValue;
          }
        }
      }
      return obj;
    }

    case "array":
      if (schema.items) {
        const itemExample = generateJsonFromSchemaObject(
          schema.items as JsonSchema,
          visitedRefs,
          rootSchema,
        );
        return [itemExample];
      }
      return [];

    case "string":
      if (schema.enum) {
        return schema.enum[0];
      }
      if (schema.const) {
        return schema.const;
      }
      if (schema.format === "date-time") {
        return new Date().toISOString();
      }
      if (schema.format === "date") {
        return new Date().toISOString().split("T")[0];
      }
      if (schema.format === "time") {
        return new Date().toISOString().split("T")[1].split(".")[0];
      }
      if (schema.format === "uri") {
        return "https://example.com";
      }
      if (schema.$ref && schema.$ref.includes("uuid")) {
        return "00000000-0000-0000-0000-000000000000";
      }
      if (schema.examples && schema.examples.length > 0) {
        return schema.examples[0];
      }

      // Handle common patterns
      if (schema.pattern) {
        if (schema.pattern === "^\\+[1-9][0-9]{0,3}$") {
          return "+1"; // Country code pattern
        }
        if (schema.pattern === "^[0-9]{3}-[0-9]{3}-[0-9]{4}$") {
          return "555-123-4567"; // US phone number pattern
        }
        if (
          schema.pattern === "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
        ) {
          return "example@example.com"; // Email pattern
        }
        // For other patterns, try to generate a simple valid value
        if (schema.pattern.includes("^\\+")) {
          return "+1"; // Generic country code
        }
        if (schema.pattern.includes("@")) {
          return "example@example.com"; // Generic email
        }
        if (schema.pattern.includes("[0-9]")) {
          return "123"; // Generic numeric string
        }
      }

      return "Sample string value";

    case "integer":
      if (schema.examples && schema.examples.length > 0) {
        return schema.examples[0];
      }
      return 10;

    case "number":
      if (schema.examples && schema.examples.length > 0) {
        return schema.examples[0];
      }
      return 100.5;

    case "boolean":
      return true;

    default:
      return null;
  }
}

/**
 * Resolves a schema reference using AJV's built-in reference resolution.
 * @param ref - The reference string (e.g., "OppStatus.yaml", "#/$defs/RecordEvent")
 * @param rootSchema - The root schema object for resolving internal $defs
 * @returns The parsed schema object, or null if the reference cannot be resolved
 */
function resolveSchemaReference(
  ref: string,
  rootSchema?: JsonSchema,
): JsonSchema | null {
  // Handle internal $defs references (e.g., "#/$defs/RecordEvent")
  if (ref.startsWith("#/$defs/")) {
    if (rootSchema && rootSchema.$defs) {
      const defName = ref.replace("#/$defs/", "");
      const defSchema = rootSchema.$defs[defName];
      if (defSchema) {
        return defSchema;
      }
    }
    return null;
  }

  // Use AJV to resolve external references
  try {
    const resolvedSchema = ajv.getSchema(ref);
    if (resolvedSchema?.schema) {
      const schema = resolvedSchema.schema as JsonSchema;
      // If the resolved schema has $defs, merge them into the rootSchema
      if (schema.$defs && rootSchema) {
        if (!rootSchema.$defs) {
          rootSchema.$defs = {};
        }
        // Merge the $defs from the resolved schema
        Object.assign(rootSchema.$defs, schema.$defs);
      }
      return schema;
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Validates generated example data against a JSON schema using AJV and logs results.
 * @param data - The generated example data to validate
 * @param schema - The JSON schema to validate against
 */
function validateGeneratedExample(data: unknown, schema: JsonSchema): void {
  const schemaId = schema.$id;
  let validate;

  if (schemaId && ajv.getSchema(schemaId)) {
    // Schema is already registered, get the existing compiled validator
    validate = ajv.getSchema(schemaId);
  } else {
    // Schema is not registered, compile it directly
    validate = ajv.compile(schema);
  }

  if (!validate(data)) {
    // Convert AJV errors to a readable format
    const errors = (validate.errors || []).map((error) => ({
      path: error.instancePath || error.schemaPath || "",
      message: error.message || "Validation failed",
      value: error.data,
    }));

    // Log warning with error count
    console.warn(
      `Warning: Generated example for schema ${schemaId || "unknown"} failed validation (${errors.length} errors)`,
    );

    // Log first 3 errors for debugging
    if (errors.length > 0) {
      console.log("Validation errors:", errors);
    }
  }
}
---

<Tabs>
  {
    exampleCode && (
      <TabItem label="Example">
        <p>A JSON example of this model.</p>
        <Code code={exampleCode} lang="json" />
      </TabItem>
    )
  }
  {
    jsonSchemaCode && (
      <TabItem label="JSON Schema">
        <p>
          The{" "}
          {jsonSchemaUrl && (
            <a href={jsonSchemaUrl} target="_blank" rel="noopener noreferrer">
              JSON Schema
            </a>
          )}{" "}
          for this model.
        </p>
        <Code code={jsonSchemaCode} lang="yaml" />
      </TabItem>
    )
  }
  {
    typeSpecCode && (
      <TabItem label="TypeSpec">
        <p>
          The{" "}
          {typeSpecUrl ? (
            <a href={typeSpecUrl} target="_blank" rel="noopener noreferrer">
              TypeSpec code
            </a>
          ) : (
            "TypeSpec code"
          )}{" "}
          for this model.
        </p>
        <Code code={typeSpecCode} lang="typespec" />
      </TabItem>
    )
  }
  {
    pythonCode && (
      <TabItem label="Python">
        <p>
          The{" "}
          {pythonUrl ? (
            <a href={pythonUrl} target="_blank" rel="noopener noreferrer">
              Python code
            </a>
          ) : (
            "Python code"
          )}{" "}
          for this model.
        </p>
        <Code code={pythonCode} lang="python" />
      </TabItem>
    )
  }
</Tabs>
